{"data":{"github":{"repository":{"object":{"__typename":"GitHub_Blob","text":"; This section mentioned a method for “simplifying” a data object by lowering it in \n; the tower of types as far as possible. Design a procedure drop that accomplishes\n; this for the tower described in Exercise 2.83. The key is to decide, in some \n; general way, whether an object can be lowered. For example, the complex number \n; 1.5 + 0i can be lowered as far as real, the complex number 1 + 0i can be lowered \n; as far as integer, and the complex number 2 + 3i cannot be lowered at all. Here is\n; a plan for determining whether an object can be lowered: Begin by defining a \n; generic operation project that “pushes” an object down in the tower. For example, \n; projecting a complex number would involve throwing away the imaginary part. Then a \n; number can be dropped if, when we project it and raise the result back to the type \n; we started with, we end up with something equal to what we started with. Show how \n; to implement this idea in detail, by writing a drop procedure that drops an object \n; as far as possible. You will need to design the various projection operations and \n; install project as a generic operation in the system. You will also need to make \n; use of a generic equality predicate, such as described in Exercise 2.79. Finally, \n; use drop to rewrite `apply-generic` from Exercise 2.84 so that it “simplifies” its \n; answers.\n\n; Source: [https://wizardbook.wordpress.com/2010/12/08/exercise-2-85/](https://wizardbook.wordpress.com/2010/12/08/exercise-2-85/)\n\n; There are 3 changes to make. The first is for apply-generic to use the new drop \n; procedure. Note that it doesn’t make sense to drop the result of all generic \n; operations, for example predicates, and that drop is only called after any type \n; coercion using raise has completed.\n(define (apply-generic op . args)\n   \n  ; only certain operations will result in an answer that can be\n  ; projected e.g. it makes no sense to project the answer to zero?\n  (define (reduce-type x)\n    (cond ((eq? op 'add) (drop x))\n          ((eq? op 'sub) (drop x))\n          ((eq? op 'mul) (drop x))\n          ((eq? op 'div) (drop x))\n          (else x)))\n   \n  ; find the highest type level of a list of arguments\n  (define (highest-type-level args)\n    (if (null? args) \n        0\n        (let ((level (type-level (car args)))\n              (highest (highest-type-level (cdr args))))\n          (if (> level highest)\n              level\n              highest))))\n   \n  ; raise arg to the same level as target-type-level\n  (define (raise-to arg target-type-level)\n    (define (raise-iter current-arg)   \n      (let ((arg-level (type-level current-arg)))\n        (cond ((= arg-level target-type-level) current-arg)\n              ((< arg-level target-type-level) (raise-iter (apply-generic 'raise current-arg)))\n              (else (error \"Cannot raise argument to a lower type target\" arg target-type-level)))))\n    (raise-iter arg))\n   \n  ; raise all args to a common type (the highest in the tower of types)\n  ; and apply the operator to them \n  (define (apply-with-raised-types args)\n    (let ((target-type-level (highest-type-level args)))\n      (apply apply-generic \n             op \n             (map (lambda (arg)\n                    (raise-to arg target-type-level))\n                  args))))\n   \n  (let* ((type-tags (map type-tag args))\n         (proc (get op type-tags)))\n    (if proc \n        (reduce-type (apply proc (map contents args)))\n        (apply-with-raised-types args))))\n\n; Second implement drop and the top-level generic project.\n\n(define (project z)  (apply-generic 'project z))\n(define (drop z)\n  (if (= (type-level z) 1) \n      z\n      (let ((projected (project z)))\n        (if (equ? z (raise projected))\n            (drop projected)\n            z))))\n\n; Third, add type specific project procedures for each type that can project.\n\n; in the rational package\n(define (project r) \n    (make-integer (truncate (/ (numer r) (denom r)))))\n(put 'project    '(rational) (lambda (x) (project x)))\n\n; in the real package - this is a bit messy because real numbers can be either \n; integers, rational or irrational.\n(define (project r) \n    (let ((exact (inexact->exact r)))\n      (cond ((integer? exact)  (make-rational exact 1))\n            ((rational? exact) (make-rational (numerator exact) (denominator exact)))\n            (else (make-rational (truncate exact) 1)))))\n(put 'project    '(real) (lambda (x) (project x)))\n\n; in the complex package\n(define (project z1)\n  (make-real (real-part z1)))\n(put 'project    '(complex) (lambda (x) (project x)))\n"}}}},"pageContext":{"name":"2.85.scm","expr":"master:sicp/ch2-abstraction-data/2.85.scm"}}