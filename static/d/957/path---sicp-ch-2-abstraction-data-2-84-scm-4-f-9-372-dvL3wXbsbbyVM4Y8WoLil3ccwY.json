{"data":{"github":{"repository":{"object":{"__typename":"GitHub_Blob","text":"; Using the raise operation of Exercise 2.83, modify the apply-generic procedure so \n; that it coerces its arguments to have the same type by the method of successive \n; raising, as discussed in this section. You will need to devise a way to test which \n; of two types is higher in the tower. Do this in a manner that is “compatible” with \n; the rest of the system and will not lead to problems in adding new levels to the \n; tower.\n\n; Source: [https://wizardbook.wordpress.com/2010/12/08/exercise-2-84/](https://wizardbook.wordpress.com/2010/12/08/exercise-2-84/)\n\n(define (apply-generic op . args)\n   \n  ; find the highest type level of a list of arguments\n  (define (highest-type-level args)\n    (if (null? args) \n        0\n        (let ((level (type-level (car args)))\n              (highest (highest-type-level (cdr args))))\n          (if (> level highest)\n              level\n              highest))))\n   \n  ; raise arg to the same level as target-type-level\n  (define (raise-to arg target-type-level)\n    (define (raise-iter current-arg)   \n      (let ((arg-level (type-level current-arg)))\n        (cond ((= arg-level target-type-level) current-arg)\n              ((< arg-level target-type-level) (raise-iter (apply-generic 'raise current-arg)))\n              (else (error \"Cannot raise argument to a lower type target\" arg target-type-level)))))\n    (raise-iter arg))\n   \n  ; raise all args to a common type (the highest in the tower of types)\n  ; and apply the operator to them \n  (define (apply-with-raised-types args)\n    (let ((target-type-level (highest-type-level args)))\n      (apply apply-generic \n             op \n             (map (lambda (arg)\n                    (raise-to arg target-type-level))\n                  args))))\n   \n  (let* ((type-tags (map type-tag args))\n         (proc (get op type-tags)))\n    (if proc \n        (apply proc (map contents args))\n        (apply-with-raised-types args))))\n\n; This uses a new top-level generic procedure to find the level of the number type \n; and a new procedure for each of the number types.\n(define (type-level z) (apply-generic 'type-level z))\n(put 'type-level '(integer) (lambda (x) 1))\n(put 'type-level '(rational) (lambda (x) 2))\n(put 'type-level '(real) (lambda (x) 3))\n(put 'type-level '(complex) (lambda (x) 4))"}}}},"pageContext":{"name":"2.84.scm","expr":"master:sicp/ch2-abstraction-data/2.84.scm"}}