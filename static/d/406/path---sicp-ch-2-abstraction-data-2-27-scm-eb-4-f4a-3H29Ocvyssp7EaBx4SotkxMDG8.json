{"data":{"github":{"repository":{"object":{"__typename":"GitHub_Blob","text":"; Modify your `reverse` procedure of Exercise 2.18 to produce a `deep-reverse` \n; procedure that takes a list as argument and returns as its value the list\n; with its elements reversed and with all sublists deep-reversed as well. \n; For example,\n; (define x (list (list 1 2) (list 3 4))) \n; x\n; ((1 2) (3 4))\n; (reverse x)\n; ((3 4) (1 2))\n; (deep-reverse x) \n; ((4 3) (2 1))\n\n(define (deep-reverse x)\n    (cond ((null? x) x)\n          ((not (pair? x)) x)\n          (else (append (deep-reverse (cdr x)) (list (deep-reverse (car x)))))))\n\n(define x (list (list 1 2) (list 3 4))) \n(deep-reverse x) ; ((4 3) (2 1))\n\n(define y (list 1 2))\n(deep-reverse y) ; (2 1)\n\n(define z (list 1 (list 4 6)))\n(deep-reverse z) ; ((6 4) 1)\n\n(define a (list (list 1 2) 3))\n(deep-reverse a) ; (3 (2 1))\n\n(define b (list (list (list 6 3) 4) 4 (list 7 8)))\n(deep-reverse b) ; ((8 7) 4 (4 (3 6)))"}}}},"pageContext":{"name":"2.27.scm","expr":"master:sicp/ch2-abstraction-data/2.27.scm"}}