{"data":{"github":{"repository":{"object":{"__typename":"GitHub_Blob","text":"; Ben Bitdiddle has invented a test to determine \n; whether the interpreter he is faced with is \n; using applicative- order evaluation or normal-order \n; evaluation. He defines the following two procedures:\n(define (p) (p))\n(define (test x y)\n  (if (= x 0) 0 y)\n)\n; Then he evaluates the expression\n;\n(test 0 (p))\n;\n; What behavior will Ben observe with an interpreter \n; that uses applicative-order evaluation? \n; What behavior will he observe with an interpreter \n; that uses normal-order evaluation? Explain your answer\n; (Assume that the evaluation rule for the special form \n; if is the same whether the interpreter is using normal \n; or applicative order: The predicate expression is evaluated \n; first, and the result determines whether to evaluate the \n; consequent or the alternative expression.)\n;\n; Answer:\n; * If the interpreter uses \"applicative-order\", \n;   (p) will be evaluated first, hence end up in infinite\n;   recursion (which is the definition of p)\n; * If the interpreter uses \"normal-order\" evaluation,\n;   (p) is not evaluated, hence will return 0\n"}}}},"pageContext":{"name":"1.05.scm","expr":"master:sicp/ch1-abstraction-procedures/1.05.scm"}}