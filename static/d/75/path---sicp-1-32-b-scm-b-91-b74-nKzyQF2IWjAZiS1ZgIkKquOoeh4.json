{"data":{"github":{"repository":{"object":{"__typename":"GitHub_Blob","text":"; If your accumulate procedure generates a recursive process,\n;  write one that generates an iterative process. If it \n; generates an iterative process, write one that generates \n; a recursive process\n\n; Iterative `accumulate`\n(define (accumulate combiner null-value term a next b)\n    (define (iter a result)\n        (if (> a b) result\n            (iter (next a) (combiner result (term a))))\n    )\n    (iter a null-value))\n\n(define (product term a next b)\n    (accumulate * 1 term a next b))\n(define (sum term a next b)\n    (accumulate + 0 term a next b))\n\n; Verify `product` by factorial\n(define (factorial n)\n    (define (f x) x)\n    (define (next x) (+ x 1))\n    (product f 1 next n))\n\n(factorial 0) ;Value: 1\n(factorial 1) ;Value: 1\n(factorial 2) ;Value: 2\n(factorial 5) ;Value: 120\n\n; Verify `sum` by `pi-sum`\n(define (pi-sum a b) \n    (define (pi-term x)\n        (/ 1.0 (* x (+ x 2)))) \n    (define (pi-next x)\n        (+ x 4))\n  (sum pi-term a pi-next b))\n(* 8 (pi-sum 1 1000)) ;Value: 3.139592655589783"}}}},"pageContext":{"name":"1.32.b.scm","expr":"master:sicp/ch1-abstraction-procedures/1.32.b.scm"}}