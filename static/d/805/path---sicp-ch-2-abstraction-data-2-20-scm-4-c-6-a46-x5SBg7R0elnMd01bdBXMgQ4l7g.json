{"data":{"github":{"repository":{"object":{"__typename":"GitHub_Blob","text":"; The procedures +, *, and list take arbitrary numbers of arguments. One \n; way to define such procedures is to use define with dotted-tail notation. \n; In a procedure definition, a parameter list that has a dot before the \n; last parameter name indicates that, when the procedure is called, the \n; initial parameters (if any) will have as values the initial arguments, \n; as usual, but the final parameter’s value will be a list of any remaining \n; arguments. For instance, given the definition\n; (define (f x y . z) ⟨body⟩)\n; the procedure f can be called with two or more arguments. If we evaluate\n; (f 1 2 3 4 5 6)\n; then in the body of f,x will be 1, y will be 2, and z will be\n; the list (3 4 5 6). Given the definition\n; (define (g . w) ⟨body⟩)\n; the procedure g can be called with zero or more arguments. If we evaluate\n; (g 1 2 3 4 5 6)\n; then in the body of g,w will be the list(1 2 3 4 5 6).\n\n; Use this notation to write a procedure same-parity that takes one or more \n; integers and returns a list of all the arguments that have the same even-odd \n; parity as the first argument. For example,\n; (same-parity 1 2 3 4 5 6 7) => (1 3 5 7)\n; (same-parity 2 3 4 5 6 7)   => (2 4 6)\n\n; Answer\n; ============================================================\n(define (append list1 list2)\n    (if (null? list1)\n        list2\n        (cons (car list1) (append (cdr list1) list2))))\n\n(define (same-parity a . args)\n    (define (same-par-nums? x y)\n        (= (remainder x 2) (remainder y 2)))\n    (define (iter margs res)\n        (if (null? margs)\n            res\n            (if (same-par-nums? a (car margs))\n                (iter (cdr margs) (append res (list (car margs))))\n                (iter (cdr margs) res))))\n    (iter args (list a)))\n\n; Testing\n(same-parity 1 2 3 4 5 6 7) ; (1 3 5 7)\n(same-parity 2 3 4 5 6 7) ; (2 4 6)"}}}},"pageContext":{"name":"2.20.scm","expr":"master:sicp/ch2-abstraction-data/2.20.scm"}}