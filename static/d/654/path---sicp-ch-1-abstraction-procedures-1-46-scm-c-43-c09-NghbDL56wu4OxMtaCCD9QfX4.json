{"data":{"github":{"repository":{"object":{"__typename":"GitHub_Blob","text":"; Several of the numerical methods described in this chapter \n; are instances of an extremely general computational strategy \n; known as iterative improvement. Iterative improvement says \n; that, to compute something, we start with an initial guess \n; for the answer, test if the guess is good enough, and otherwise \n; improve the guess and continue the process using the improved \n; guess as the new guess. Write a procedure iterative-improve \n; that takes two procedures as arguments: a method for telling\n; whether a guess is good enough and a method for improving a \n; guess. iterative-improve should return as its value a procedure \n; that takes a guess as argument and keeps improving the guess \n; until it is good enough. Rewrite the sqrt procedure of Section 1.1.7 \n; and the fixed-point procedure of Section 1.3.3 in terms of \n; iterative-improve.\n\n(define (iterative-improve good-enough? improve)\n    (lambda (guess) \n        (if (good-enough? guess) guess\n        ((iterative-improve good-enough? improve) (improve guess)))))\n\n; (i) Re-write sqrt\n(define (sqrt-iter x)\n    (define (avg a b) (/ (+ a b) 2))\n    (define (good-enough? guess)\n        (< (abs (- (square guess) x)) 0.001))\n    (define (improve guess)\n        (avg guess (/ x guess)))\n    ((iterative-improve good-enough? improve) 1.0))\n\n(sqrt-iter 69) ;Value: 8.306626993523448\n\n; (ii) Re-write `fixed-point`\n(define (fixed-point f first-guess)\n    (define (close-enough? v1 v2)\n        (< (abs (- v1 v2)) 0.00001))\n    ((iterative-improve\n        (lambda (x) (close-enough? x (f x)))\n        f) first-guess))\n\n(fixed-point \n    (lambda (x) (+ 1 (/ 1 x))) \n    1.0) ;Value: 1.6180327868852458 (~= Ï†, golden ratio)"}}}},"pageContext":{"name":"1.46.scm","expr":"master:sicp/ch1-abstraction-procedures/1.46.scm"}}