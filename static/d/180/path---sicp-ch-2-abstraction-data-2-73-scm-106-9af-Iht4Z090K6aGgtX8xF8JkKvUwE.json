{"data":{"github":{"repository":{"object":{"__typename":"GitHub_Blob","text":"; Section 2.3.2 described a program that performs symbolic differentiation:\n\n(define (deriv exp var) \n    (cond ((number? exp) 0)\n          ((variable? exp)\n            (if (same-variable? exp var) 1 0))\n          ((sum? exp)\n               (make-sum (deriv (addend exp) var)\n                         (deriv (augend exp) var)))\n          ((product? exp)\n                (make-sum (make-product\n                            (multiplier exp)\n                            (deriv (multiplicand exp) var))\n                          (make-product\n                            (deriv (multiplier exp) var)\n                            (multiplicand exp))))\n          (else (error \"unknown expression type: \n                       DERIV\" exp))))\n\n; We can regard this program as performing a dispatch on the type of the expression \n; to be differentiated. In this situation the “type tag” of the datum is the \n; algebraic operator symbol (such as +) and the operation being performed is deriv. \n; We can transform this program into data-directed style by rewriting the basic \n; derivative procedure as\n\n(define (deriv exp var) \n    (cond ((number? exp) 0)\n          ((variable? exp) (if (same-variable? exp var) 1 0)) \n          (else ((get 'deriv (operator exp))\n                 (operands exp) var)))) \n(define (operator exp) (car exp))\n(define (operands exp) (cdr exp))\n\n; (a) Explain what was done above. Why can’t we assimilate the predicates number? \n;     and variable? into the data-directed dispatch?\n\n; Ans:\n; number? and variable? do not use any operator or operands. Hence there's no need\n; of dispatch method\n\n; (b) Write the procedures for derivatives of sums and products, and the auxiliary \n;     code required to install them in the table used by the program above\n\n; Ans:\n\n(define (deriv-sum exp var)\n    (make-sum (deriv (addend exp) var)\n              (deriv (augend exp) var)))\n(define (deriv-product exp var)\n    (make-sum (make-product \n                (multiplier exp)\n                (deriv (multiplicand exp) var))\n              (make-product\n                (deriv (multiplier exp) var)\n                (multiplicand exp))))\n\n(deriv (install-deriv)\n    (put 'deriv '+ deriv-sum)\n    (put 'deriv '* deriv-product)\n    'done)\n\n; (c) Choose any additional differentiation rule that you like, such as the one for \n;     exponents (Exercise 2.56), and install it in this data-directed system.\n\n; Ans:\n(define (deriv-expo exp var)\n    (define b (base exp))\n    (define e (exponent exp))\n    (make-product\n        e\n        (make-product\n            (make-exp b (make-sum e -1))\n            (deriv b var))))\n\n(define (install-expo)\n    (put 'deriv '** deriv-expo))\n\n; (d) In this simple algebraic manipulator the type of an expression is the algebraic\n;     operator that binds it together. Suppose, however, we indexed the procedures \n;     in the opposite way, so that the dispatch line in `deriv` looked like\n;  \n;     ((get (operator exp) 'deriv) (operands exp) var)\n;   \n;     What corresponding changes to the derivative system are required?\n\n; Ans:\n; We need to reverse the map\n(put '+ 'deriv deriv-sum)\n(put '* 'deriv deriv-product)\n"}}}},"pageContext":{"name":"2.73.scm","expr":"master:sicp/ch2-abstraction-data/2.73.scm"}}