{"data":{"github":{"repository":{"object":{"__typename":"GitHub_Blob","text":"; You can obtain an even more general version of \n; accumulate (Exercise 1.32) by introducing the notion \n; of a filter on the terms to be combined. That is, \n; combine only those terms derived from values in the \n; range that satisfy a specified condition. The resulting \n; `filtered-accumulate` abstraction takes the same \n; arguments as `accumulate`, together with an additional \n; predicate of one argument that specifies the filter. \n; Write `filtered-accumulate` as a procedure. Show how \n; to express the following using filtered-accumulate:\n; (a) the sum of the squares of the prime numbers in the \n;     interval a to b (assuming that you have a prime? \n;     predicate already written)\n\n; (b) the product of all the positive integers less than n \n;     are relatively prime to n (i.e., all positive integers \n;     i < n such that GCD(i,n) = 1).\n\n; -----------------------------------\n; Answer\n; -----------------------------------\n; Let's define `filtered-accumulate` function\n\n(define (filtered-accumulate combiner null-value filter term a next b)\n    (if (> a b) null-value\n        (if (filter a)\n            (combiner (term a) \n                      (filtered-accumulate combiner null-value filter term (next a) next b))\n            (combiner null-value \n                      (filtered-accumulate combiner null-value filter term (next a) next b)))))\n\n; (a) Let's test with `prime?` procedure\n(define (prime? n)\n    (define (divides? a b) (= (remainder b a) 0))\n    (define (smallest-divisor n) (find-divisor n 2))\n    (define (find-divisor n test-divisor)\n        (cond ((> (square test-divisor) n) n)\n              ((divides? test-divisor n) test-divisor)\n              (else (find-divisor n (+ test-divisor 1)))))\n    (if (= n 1) #f\n        (= n (smallest-divisor n)))\n)\n(define (inc x) (+ x 1))\n(define (sum-of-squares-prime a b)\n    (filtered-accumulate + 0 prime? square a inc b))\n\n(sum-of-squares-prime 1 10) ;Value: 87 (2^2 + 3^2 + 5^2 + 7^2)\n\n; (b) Define `relatively-prime?` filter\n(define (gcd a b) \n    (cond ((< a b) (gcd b a)) \n          ((= b 0) a) \n          (else (gcd b (remainder a b))))) \n   \n(define (relatively-prime? a b)\n    (= (gcd a b) 1))\n(define (product-of-relative-prime-nums n)\n    (define (filter x) (relatively-prime? x n))\n    (define (f x) x)\n    (filtered-accumulate * 1 filter f 1 inc n)\n)\n(product-of-relative-prime-nums 10) ;Value: 189"}}}},"pageContext":{"name":"1.33.scm","expr":"master:sicp/ch1-abstraction-procedures/1.33.scm"}}