{"data":{"github":{"repository":{"object":{"__typename":"GitHub_Blob","text":"; Suppose we represent vectors v = (v_i) as sequences of numbers, and matrices \n; m = (m_{ij}) as sequences of vectors (the rows of the matrix). For example, the \n; matrix\n;  1 2 3 4\n;  4 5 6 6\n;  6 7 8 9\n; is represented as the sequence ((1 2 3 4) (4 5 6 6) (6 7 8 9)). With this \n; representation, we can use sequence operations to concisely express the basic \n; matrix and vector operations. These operations (which are described in any book \n; on matrix algebra) are the following:\n; (dot-product v w)     returns the sum Σiviwi;\n; (matrix-*-vector m v) returns the vector t, whereti =Σjmijvj;\n; (matrix-*-matrix m n) returns the matrix p, wherepij =Σkmiknkj;\n; (transpose m)         returns the matrix n, wherenij =mji.\n; \n; We can define the dot product as,\n; (define (dot-product v w)\n;   (accumulate + 0 (map * v w)))\n; Fill in the missing expressions in the following procedures for computing \n; the other matrix operations. (The procedure accumulate-n is defined in \n; Exercise 2.36.)\n; (define (matrix-*-vector m v) (map ⟨??⟩ m))\n; (define (transpose mat) (accumulate-n ⟨??⟩ ⟨??⟩ mat))\n; (define (matrix-*-matrix m n) (let ((cols (transpose n)))\n;     (map ⟨??⟩ m)))\n\n(define nil '())\n(define (accumulate op initial sequence)\n    (if (null? sequence) \n        initial\n        (op (car sequence) (accumulate op initial (cdr sequence)))))\n(define (accumulate-n op initial seqs)\n    (if (null? (car seqs))\n        nil\n        (cons (accumulate op initial (map car seqs))\n              (accumulate-n op initial (map cdr seqs)))))\n\n; Dot product \n(define (dot-product v w)\n    (accumulate + 0 (map * v w)))\n\n; Matrix x Vector\n(define (matrix-*-vector m v)\n    (map (lambda (x) (dot-product x v)) m))\n\n; Transpose\n(define (transpose mat)\n    (accumulate-n cons nil mat))\n\n; Matrix x Matrix\n(define (matrix-*-matrix m n)\n    (let ((cols (transpose n)))\n        (map (lambda (row) \n                (matrix-*-vector cols row))\n             m)))\n\n; Testing\n(define v1 (list 1 2 3 4))\n(define v2 (list 2 3 4 5))\n\n; Dot product v1 \\cdot v2 = 1x2 + 2x3 + 3x4 + 4x5 = 40\n(dot-product v1 v2) ;Value: 40\n\n(define m1 (list (list 1 3 4) (list 1 0 1) (list 2 1 4)))\n(define v3 (list 1 2 3))\n\n; m1 x v3\n(matrix-*-vector m1 v3) ;(19 4 16)\n\n(define m2 (list (list 0 0 1) (list 2 3 5) (list 1 2 9)))\n(matrix-*-matrix m1 m2) ; ((10 17 52) (1 2 10) (6 11 43))\n\n(transpose m1) ; ((1 1 2) (3 0 1) (4 1 4))"}}}},"pageContext":{"name":"2.37.scm","expr":"master:sicp/ch2-abstraction-data/2.37.scm"}}