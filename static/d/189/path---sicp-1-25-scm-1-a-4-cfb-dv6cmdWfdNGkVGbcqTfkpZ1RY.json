{"data":{"github":{"repository":{"object":{"__typename":"GitHub_Blob","text":"; Alyssa P. Hacker complains that we went to a lot of \n; extra work in writing expmod. After all, she says, \n; since we already know how to compute exponentials, \n; we could have simply written\n; \n(define (expmod base exp m) \n    (remainder (fast-expt base exp) m))\n; \n; Is she correct? Would this procedure serve as well for \n; our fast prime tester? Explain.\n(define (even? x) (= (remainder x 2) 0))\n(define (expmod-prev base exp m)\n    (cond ((= exp 0) 1)\n          ((even? exp)\n           (remainder\n            (square (expmod-prev base (/ exp 2) m))\n             m)) \n          (else\n            (remainder\n             (* base (expmod-prev base (- exp 1) m))\n             m))))\n(define (fast-expt b n)\n    (define (even? n) (= (remainder n 2) 0))\n    (cond ((= n 0) 1)\n          ((even? n) (square (fast-expt b (/ n 2))))\n          (else (* b (fast-expt b (- n 1))))))\n\n; Let's test whether both `expmod-prev` and `expmod` return\n; correct result for some values\n(expmod-prev 6 97 97) ;Value: 6\n(expmod 6 97 97)      ;Value: 6\n\n(expmod-prev 103 1000003 1000003) ;Value: 103\n(expmod 103 1000003 1000003)      ;Value: 103\n\n; We can also observe that the current `expmod` takes more\n; time for large numbers, as it computes very large\n; intermediate values"}}}},"pageContext":{"name":"1.25.scm","expr":"master:sicp/ch1-abstraction-procedures/1.25.scm"}}