{"data":{"github":{"repository":{"object":{"__typename":"GitHub_Blob","text":"; The exponentiation algorithms in this section are \n; based on performing exponentiation by means of repeated \n; multiplication. In a similar way, one can perform integer \n; multiplication by means of repeated addition. The following \n; multiplication procedure (in which it is assumed that our \n; language can only add, not multiply) is analogous to the \n; `expt` procedure\n(define (* a b) \n    (if (= b 0)\n        0\n        (+ a (* a (- b 1)))))\n\n; This algorithm takes a number of steps that is linear in b. \n; Now suppose we include, together with addition, operations `double`, \n; which doubles an integer, and `halve`, which divides an (even) integer by 2. \n; Using these, design a multiplication procedure analogous to `fast-expt` that \n; uses a logarithmic number of steps.\n(define (fast-mul a b)\n    (define (even? x) (= (remainder x 2) 0))\n    (define (double x) (+ x x))\n    (define (halve x) (/ x 2))\n    (cond ((= b 0) 0)\n        ((even? b) (fast-mul (double a) (halve b)))\n        (else (+ a (fast-mul a (- b 1))))\n    )\n)\n(fast-mul 2 6) ;Value: 12\n(fast-mul 24 67) ;Value: 1608\n(fast-mul 1 7) ;Value: 7"}}}},"pageContext":{"name":"1.17.scm","expr":"master:sicp/ch1-abstraction-procedures/1.17.scm"}}