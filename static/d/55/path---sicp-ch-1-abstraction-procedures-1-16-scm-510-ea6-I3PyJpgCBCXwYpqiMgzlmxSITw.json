{"data":{"github":{"repository":{"object":{"__typename":"GitHub_Blob","text":"; Design a procedure that evolves an iterative \n; exponentiation process that uses successive squaring\n; and uses a logarithmic number of steps, as does `fast-expt`\n; (Hint: Using the observation that (bn/2)2 = (b2)n/2, keep, \n; along with the exponent n and the base b, an additional state variable a, \n; and define the state transformation in such a way that the product ab^n is \n; unchanged from state to state. At the beginning of the process a is taken to be 1, \n; and the answer is given by the value of a at the end of the process. \n; In general, the technique of defining an invariant quantity that remains unchanged \n; from state to state is a powerful way to think about the design of \n; iterative algorithms.)\n(define (fast-expt b n)\n    (define (even? n) (= (remainder n 2) 0))\n    (define (fast-expt-iter base counter prod)\n        (cond ((= counter 0) prod)\n              ((even? counter) (fast-expt-iter (square base) (/ counter 2) prod))\n              (else (fast-expt-iter base (- counter 1) (* base prod)))\n        )\n    )\n    (fast-expt-iter b n 1)\n)\n\n(fast-expt 2 10) ;Value: 1024\n(fast-expt 2 5) ;Value: 32\n(fast-expt 2 1000) ;Value: 1071508607186267320948425049\n;0600018105614048117055336074437503883703510511249361224931\n;98378815695858127594672917553146825187145285692314043598457\n;757469857480393456777482423098542107460506237114187795418215\n;30464749835819412673987675591655439460770629145711964776865421\n;67660429831652624386837205668069376\n"}}}},"pageContext":{"name":"1.16.scm","expr":"master:sicp/ch1-abstraction-procedures/1.16.scm"}}