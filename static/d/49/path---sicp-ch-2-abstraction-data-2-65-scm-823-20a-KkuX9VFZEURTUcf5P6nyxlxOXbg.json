{"data":{"github":{"repository":{"object":{"__typename":"GitHub_Blob","text":"; Use the results of Exercise 2.63 and Exercise 2.64 to give Î˜(n) implementations \n; of `union-set` and `intersection-set` for sets implemented as (balanced) binary \n; trees\n\n(define (entry tree) (car tree))\n(define (left-branch tree) (cadr tree))\n(define (right-branch tree) (caddr tree))\n\n(define (make-tree entry left right)\n    (list entry left right))\n\n(define (tree->list tree)\n    (define (copy-to-list tree result-list)\n        (if (null? tree)\n            result-list\n            (copy-to-list (left-branch tree)\n                          (cons (entry tree)\n                                (copy-to-list\n                                    (right-branch tree)\n                                    result-list)))))\n    (copy-to-list tree '()))\n\n(define (list->tree elements)\n    (car (partial-tree elements (length elements))))\n\n(define (partial-tree elts n)\n  (if (= n 0)\n      (cons '() elts)\n      (let ((left-size (quotient (- n 1) 2)))\n        (let ((left-result\n                (partial-tree elts left-size)))\n          (let ((left-tree (car left-result)) \n                (non-left-elts (cdr left-result))\n                (right-size (- n (+ left-size 1))))\n            (let ((this-entry (car non-left-elts)) \n                  (right-result\n                    (partial-tree\n                      (cdr non-left-elts)\n                      right-size)))\n                (let ((right-tree (car right-result)) \n                      (remaining-elts\n                        (cdr right-result)))\n                    (cons (make-tree this-entry\n                                     left-tree\n                                     right-tree)\n                          remaining-elts))))))))\n\n; Union using ordered list\n(define (union-set-list set1 set2)\n    (cond ((null? set1) set2)\n          ((null? set2) set1)\n          (else\n            (let ((x1 (car set1))\n                  (x2 (car set2)))\n                (cond ((= x1 x2)\n                       (cons x1 (union-set-list (cdr set1) (cdr set2))))\n                      ((> x1 x2)\n                       (cons x2 (union-set-list set1 (cdr set2))))\n                      (else\n                        (cons x1 (union-set-list (cdr set1) set2))))))))\n(define (union-set set1 set2)\n    (list->tree (union-set-list\n                    (tree->list set1)\n                    (tree->list set2))))\n\n; Intersection using ordered list\n(define (intersection-set-list set1 set2) \n    (if (or (null? set1) (null? set2))\n        '()\n        (let ((x1 (car set1)) (x2 (car set2)))\n          (cond ((= x1 x2)\n                 (cons x1 (intersection-set-list (cdr set1)\n                                            (cdr set2))))\n                ((< x1 x2)\n                 (intersection-set-list (cdr set1) set2))\n                ((< x2 x1)\n                 (intersection-set-list set1 (cdr set2)))))))\n(define (intersection-set set1 set2)\n    (list->tree (intersection-set-list\n                    (tree->list set1)\n                    (tree->list set2))))\n\n(tree->list (union-set \n    (list->tree '(1 2 3 5 6 8 12))  \n    (list->tree '(5 6 9 10 12 13 15))))\n; (1 2 3 5 6 8 9 10 12 13 15)\n\n(tree->list (intersection-set \n    (list->tree '(1 2 3 5 6 8 12))  \n    (list->tree '(5 6 9 10 12 13 15))))\n; (5 6 12)"}}}},"pageContext":{"name":"2.65.scm","expr":"master:sicp/ch2-abstraction-data/2.65.scm"}}