{"data":{"github":{"repository":{"object":{"__typename":"GitHub_Blob","text":"; Louis Reasoner has noticed that `apply-generic` may try to coerce the arguments to \n; each other’s type even if they already have the same type. Therefore, he reasons, \n; we need to put procedures in the coercion table to coerce arguments of each type to\n; their own type. For example, in addition to the `scheme-number->complex` coercion \n; shown above, he would do:\n(define (scheme-number->scheme-number n) n) \n(define (complex->complex z) z)\n(put-coercion 'scheme-number\n              'scheme-number\n              scheme-number->scheme-number)\n(put-coercion 'complex 'complex complex->complex)\n\n; (a) With Louis’s coercion procedures installed, what hap-pens if apply-generic is \n;     called with two arguments of type `scheme-number` or two arguments of type \n;     `complex` for an operation that is not found in the table for those types? \n;      For example, assume that we’ve defined a generic exponentiation operation:\n(define (exp x y) (apply-generic 'exp x y))\n\n; and have put a procedure for exponentiation in the Scheme-number package but not \n; in any other package:\n\n;; following added to Scheme-number package\n(put 'exp '(scheme-number scheme-number) \n    (lambda (x y) (tag (expt x y)))) ; using primitive expt\n\n; What happens if we call exp with two complex numbers as arguments?\n\n; Ans\n; `apply-generic` procedure will be called infinitely\n\n; (b) Is Louis correct that something had to be done about coercion with arguments \n;     of the same type, or does `apply-generic` work correctly as is?\n\n; Ans\n; `apply-generic` works fine as it is.\n\n; (c) Modify `apply-generic` so that it doesn’t try coercion if the two arguments \n;     have the same type.\n(define (apply-generic op . args)\n    (let ((type-tags (map type-tag args)))\n        (let ((proc (get op type-tags))) \n            (if proc\n                (apply proc (map contents args)) \n                (if (= (length args) 2)\n                    (let ((type1 (car type-tags)) \n                          (type2 (cadr type-tags)) \n                          (a1 (car args))\n                          (a2 (cadr args)))\n                        (if (eq? type1 type2)\n                            (error \"No method for these types\"\n                                (list op type-tags))\n                            (let ((t1->t2 (get-coercion type1 type2)) \n                                  (t2->t1 (get-coercion type2 type1)))\n                              (cond (t1->t2\n                                      (apply-generic op (t1->t2 a1) a2))\n                                    (t2->t1\n                                      (apply-generic op a1 (t2->t1 a2)))\n                                    (else (error \"No method for these types\" \n                                      (list op type-tags)))))))\n                    (error \"No method for these types\"\n                           (list op type-tags)))))))\n"}}}},"pageContext":{"name":"2.81.scm","expr":"master:sicp/ch2-abstraction-data/2.81.scm"}}