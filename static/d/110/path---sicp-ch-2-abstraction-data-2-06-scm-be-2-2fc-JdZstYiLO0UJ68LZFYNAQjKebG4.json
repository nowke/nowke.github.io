{"data":{"github":{"repository":{"object":{"__typename":"GitHub_Blob","text":"; In case representing pairs as procedures wasn’t mind-boggling enough, \n; consider that, in a language that can manipulate procedures, we can \n; get by without numbers (at least insofar as nonnegative integers are \n; concerned) by implementing 0 and the operation of adding 1 as\n(define zero (lambda (f) (lambda (x) x))) \n(define (add-1 n)\n    (lambda (f) (lambda (x) (f ((n f) x)))))\n; This representation is known as Church numerals, after its inventor, \n; Alonzo Church, the logician who invented the λ- calculus.\n; Define `one` and `two` directly (not in terms of zero and add- 1). \n; (Hint: Use substitution to evaluate (add-1 zero)). Give a direct \n; definition of the addition procedure + (not in terms of repeated \n; application of add-1).\n\n; (i) Getting `one` by substitution (add-1 zero)\n; ------------------------------------------------------------------\n; (add-1 zero)\n; (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) x)) f) x))))\n; (lambda (f) (lambda (x) (f ((lambda (x) x) x))))\n; (lambda (f) (lambda (x) (f x)))\n(define one \n    (lambda (f) (lambda (x) (f x))))\n\n; (ii) Getting `two` by substitution (add-1 one)\n; ------------------------------------------------------------------\n; (add-1 one)\n; (lambda (f) (lambda (x) (f ((one f) x))))\n; (lambda (f) (lambda (x) (f (((lambda (f) (lambda (x) (f x))) f) x))))\n; (lambda (f) (lambda (x) (f ((lambda (x) (f x)) x))))\n; (lambda (f) (lambda (x) (f (f x))))\n(define two\n    (lambda (f) (lambda (x) (f (f x)))))\n\n; (iii) Generalizing (addition a b)\n; (Note: This was confusing to me! Had to look up for the solution.\n;        A good explanation is available. Just Google)\n(define (addition a b)\n    (lambda (f) (lambda (x) ((a f) ((b f) x)))))\n"}}}},"pageContext":{"name":"2.06.scm","expr":"master:sicp/ch2-abstraction-data/2.06.scm"}}