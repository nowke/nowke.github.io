{"data":{"github":{"repository":{"object":{"__typename":"GitHub_Blob","text":"; In passing, Ben also cryptically comments: “By testing the \n; signs of the endpoints of the intervals, it is possible to \n; break mul-interval into nine cases, only one of which \n; requires more than two multiplications.” Rewrite this procedure \n; using Ben’s suggestion\n\n; Answer\n; ------------------------------------\n; The nine cases are based on 3 signs of x and y\n; x can have [-ve, -ve], [-ve, +ve] and [+ve, +ve] (3)\n;  (Note: [+ve, -ve] is NOT possible since order is always [lower, upper])\n; y can have [-ve, -ve], [-ve, +ve] and [+ve, +ve] (3)\n; Hence there can be 3x3 = 9 possibilities.\n\n; Let's associate a value to each combination\n; [-ve, -ve] => -1, [-ve, +ve] => 0, [+ve, +ve] => 1\n; and define a function that returns us this value\n(define (get-pair-value low up)\n    (cond ((and (< low 0) (< up 0)) -1)\n          ((and (< low 0) (> up 0)) 0)\n          (else 1)))\n\n; We can modify our `make-interval` to make sure always (a, b) has\n; the property a < b\n(define (make-interval a b)\n    (cons (min a b) (max a b)))\n(define (lower-bound z) (car z))\n(define (upper-bound z) (cdr z))\n(define (print-interval z)\n    (newline)\n    (display \"[\")\n    (display (lower-bound z))\n    (display \", \")\n    (display (upper-bound z))\n    (display \"]\"))\n\n; Let's rewrite our `mul-interval` procedure\n(define (mul-interval x y)\n    (define xlow (lower-bound x))\n    (define xup  (upper-bound x))\n    (define ylow (lower-bound y))\n    (define yup  (upper-bound y))\n\n    (define xval (get-pair-value xlow xup))\n    (define yval (get-pair-value ylow yup))\n\n    (cond ((= xval -1)\n           (cond ((= yval -1)            ; [-ve, -ve], [-ve, -ve]\n                  (make-interval (* xup yup) (* xlow ylow)))\n                 ((= yval 0)             ; [-ve, -ve], [-ve, +ve]\n                  (make-interval (* xlow yup) (* xlow ylow)))\n                 (else                   ; [-ve, -ve], [+ve, +ve]\n                  (make-interval (* xlow yup) (* xup ylow)))))\n          ((= xval 0)\n           (cond ((= yval -1)            ; [-ve, +ve], [-ve, -ve]\n                  (make-interval (* xup ylow) (* xlow ylow)))\n                 ((= yval 0)             ; [-ve, +ve], [-ve, +ve]\n                  (make-interval \n                    (min (* xlow yup)  (* xup ylow)) \n                    (max (* xlow ylow) (* xup yup))))\n                 (else                   ; [-ve, +ve], [+ve, +ve]\n                  (make-interval (* xlow yup) (* xup yup)))))\n          (else\n           (cond ((= yval -1)            ; [+ve, +ve], [-ve, -ve]\n                  (make-interval (* xup ylow) (* xlow yup)))\n                 ((= yval 0)             ; [+ve, +ve], [-ve, +ve]\n                  (make-interval (* xup ylow) (* xup yup)))\n                 (else                   ; [+ve, +ve], [+ve, +ve]\n                  (make-interval (* xlow ylow) (* xup yup)))))))\n\n; Testing\n(print-interval (mul-interval \n    (make-interval -1.5 -1.2) \n    (make-interval -1   2))) ; [-3., 1.5]\n\n(print-interval (mul-interval \n    (make-interval -5 3) \n    (make-interval -2 4)))   ; [-20, 12]  "}}}},"pageContext":{"name":"2.11.scm","expr":"master:sicp/ch2-abstraction-data/2.11.scm"}}