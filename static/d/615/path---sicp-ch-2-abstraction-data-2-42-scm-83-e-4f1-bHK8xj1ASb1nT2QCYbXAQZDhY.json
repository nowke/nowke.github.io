{"data":{"github":{"repository":{"object":{"__typename":"GitHub_Blob","text":"; The “eight-queens puzzle” asks how to place eight queens on a chessboard so that \n; no queen is in check from any other (i.e., no two queens are in the same row, \n; column, or diagonal). One possible solution is shown in Figure 2.8. One way to \n; solve the puzzle is to work across the board, placing a queen in each column. \n; Once we have placed k−1 queens, we must place the kth queen in a position where \n; it does not check any of the queens already on the board. We can formulate this \n; approach recursively: Assume that we have already generated the sequence of all \n; possible ways to place k − 1 queens in the first k − 1 columns of the board. For \n; each of these ways, generate an extended set of positions by placing a queen in \n; each row of the kth column. Now filter these, keeping only the positions for \n; which the queen in the kth column is safe with respect to the other queens. This \n; produces the sequence of all ways to place k queens in the first k columns. \n; By continuing this process, we will produce not only one solution, but all \n; solutions to the puzzle.\n; We implement this solution as a procedure queens, which returns a sequence of all \n; solutions to the problem of placing n queens on an n × n chessboard. queens has \n; an internal procedure queen-cols that returns the sequence of all ways to place \n; queens in the first k columns of the board.\n(define (queens board-size)\n  (define (queen-cols k)\n    (if (= k 0)\n        (list empty-board)\n        (filter\n          (lambda (positions) (safe? k positions))\n          (flatmap\n            (lambda (rest-of-queens)\n              (map (lambda (new-row)\n                     (adjoin-position \n                        new-row k rest-of-queens))\n                   (enumerate-interval 1 board-size)))\n            (queen-cols (- k 1))))))\n  (queen-cols board-size))\n\n; In this procedure rest-of-queens is a way to place k − 1 queens in the first \n; k − 1 columns, and new-row is a proposed row in which to place the queen for \n; the kth column. Complete the program by implementing the representation for \n; sets of board positions, including the procedure adjoin-position, which adjoins \n; a new row-column position to a set of positions, and empty-board, which represents \n; an empty set of positions. You must also write the procedure safe?, which \n; determines for a set of positions, whether the queen in the kth column is safe \n; with respect to the others. (Note that we need only check whether the new queen \n; is safe — the other queens are already guaranteed safe with respect to each other.)\n\n; Define `enumerate-interval`, and `flatmap` procedures\n(define nil '())\n(define (enumerate-interval low high)\n    (if (> low high)\n        nil\n        (cons low (enumerate-interval (+ low 1) high))))\n(define (accumulate op initial sequence)\n    (if (null? sequence) \n        initial\n        (op (car sequence) (accumulate op initial (cdr sequence)))))\n(define (flatmap proc seq)\n    (accumulate append nil (map proc seq)))\n\n; (i) Define `empty board`\n(define empty-board nil)\n\n; (ii) Define `safe?` procedure\n; \n; Let's solve the problem part by part. First of all, the data structure\n; of `positions`, i.e. one of the argument to `safe?` is as follows\n; \n; (((1 1) (3 2) (5 3) (1 4))\n; This means, column 1 => (pos 1)\n;             column 2 => (pos 3)\n;             column 3 => (pos 5)\n;         kth-column 4 => (pos 1)\n; i.e. Column 1-3 => queens are already safe\n;        and we want to test at k=4, 4th column and \n;        whether position \"1\" is safe or not\n;\n; We can check against each of Col 1-3, for any dangers\n; Here, danger for `kth-column` from `nth-col` means 3 conditions\n;     1) Position of nth-col = Position of kth-col => Same row\n;     2) Diagonal of nth-col in kth-col = kth-col\n;     3) Skew-diagonal of nth-col in kth-col = kth-col \n\n(define (row-diag row-val row k)\n    (+ row-val (- k row)))\n(define (skew-diag row-val row k)\n    (- row-val (- k row)))\n\n(define (pair-safe? p1 p2)\n    (define row     (cadr p1))\n    (define row-val (car p1))\n    (define k       (cadr p2))\n    (define k-val   (car p2))\n    (not \n      (or (= row-val k-val)\n          (= (row-diag  row-val row k) k-val)\n          (= (skew-diag row-val row k) k-val))))\n\n(define (safe? k positions)\n    ; ((1 1) (3 2) (5 3) (1 4)) => (1 4) - test-value\n    (define test-value (last positions))\n    (define (iter x positions)\n        (cond ((= x k) #t)\n              ((pair-safe? (car positions) test-value)\n               (iter (+ x 1) (cdr positions)))\n              (else #f)\n        )\n    )\n    (iter 1 positions))\n\n; In the setting, ((1 1) (3 2) (5 3))\n; we can test which row suites for 4th column (k = 4)\n; If we draw the board, we can observe that 2nd row is the only \n; suitable position\n; Let's test this with `safe?` procedure\n\n(safe? 4 (list (list 1 1) (list 3 2) (list 5 3) (list 1 4))) ;Value: #f\n(safe? 4 (list (list 1 1) (list 3 2) (list 5 3) (list 2 4))) ;Value: #t\n(safe? 4 (list (list 1 1) (list 3 2) (list 5 3) (list 3 4))) ;Value: #f\n(safe? 4 (list (list 1 1) (list 3 2) (list 5 3) (list 4 4))) ;Value: #f\n(safe? 4 (list (list 1 1) (list 3 2) (list 5 3) (list 5 4))) ;Value: #f\n\n; (iii) Define `adjoin-position` procedure\n; Example\n; ----------------------\n; Input: new-row        = 1\n;        k              = 4\n;        rest-of-queens = ((1 1) (3 2) (5 3))       \n; Output: ((1 1) (3 2) (5 3) (1 4))\n(define (adjoin-position new-row k rest-of-queens)\n    (append rest-of-queens (list (list new-row k))))\n\n; Testing for queens 4, 5, 6\n(queens 4)\n; (((2 1) (4 2) (1 3) (3 4)) \n;  ((3 1) (1 2) (4 3) (2 4))) => 2 solutions\n\n(queens 5)\n; (((1 1) (3 2) (5 3) (2 4) (4 5)) \n;  ((1 1) (4 2) (2 3) (5 4) (3 5)) \n;  ((2 1) (4 2) (1 3) (3 4) (5 5)) \n;  ((2 1) (5 2) (3 3) (1 4) (4 5)) \n;  ((3 1) (1 2) (4 3) (2 4) (5 5)) \n;  ((3 1) (5 2) (2 3) (4 4) (1 5))\n;  ((4 1) (1 2) (3 3) (5 4) (2 5))\n;  ((4 1) (2 2) (5 3) (3 4) (1 5)) \n;  ((5 1) (2 2) (4 3) (1 4) (3 5)) \n;  ((5 1) (3 2) (1 3) (4 4) (2 5))) => 10 solutions\n\n(queens 6)\n; (((2 1) (4 2) (6 3) (1 4) (3 5) (5 6)) \n;  ((3 1) (6 2) (2 3) (5 4) (1 5) (4 6)) \n;  ((4 1) (1 2) (5 3) (2 4) (6 5) (3 6)) \n;  ((5 1) (3 2) (1 3) (6 4) (4 5) (2 6))) => 4 solutions\n"}}}},"pageContext":{"name":"2.42.scm","expr":"master:sicp/ch2-abstraction-data/2.42.scm"}}