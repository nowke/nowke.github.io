{"data":{"github":{"repository":{"object":{"__typename":"GitHub_Blob","text":"; The `sum` procedure is only the simplest of a vast \n; number of similar abstractions that can be captured \n; as higher-order procedures. Write an analogous procedure \n; called `product` that returns the product of the values \n; of a function at points over a given range. Show how to \n; define `factorial` in terms of `product`. Also use `product` \n; to compute approximations to π using the formula\n; π/4 = (2/3)(4/3)(4/5)(6/5)(6/7)(8/7)\n(define (product term a next b)\n    (if (> a b) 1\n        (* (term a)\n           (product term (next a) next b))))\n\n; Define `factorial`\n(define (factorial n)\n    (define (f x) x)\n    (define (next x) (+ x 1))\n    (product f 1 next n))\n\n(factorial 0) ;Value: 1\n(factorial 1) ;Value: 1\n(factorial 2) ;Value: 2\n(factorial 5) ;Value: 120\n\n(define (pi-term n)\n    (cond ((even? n)\n            (/ (+ n 2) (+ n 1)))\n           (else (/ (+ n 1) (+ n 2)))))\n(define (pi-sum n)\n    (define (next x) (+ x 1))\n    (product pi-term 1 next n)\n)\n(* (pi-sum 10) 4.0)   ;Value: 3.2751010413348074\n(* (pi-sum 1000) 4.0) ;Value: 3.1431607055322663"}}}},"pageContext":{"name":"1.31.a.scm","expr":"master:sicp/ch1-abstraction-procedures/1.31.a.scm"}}