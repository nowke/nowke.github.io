{"data":{"github":{"repository":{"object":{"__typename":"GitHub_Blob","text":"; Suppose we want to have a polynomial system that is efficient for both sparse and \n; dense polynomials. One way to do this is to allow both kinds of term-list \n; representations in our system. The situation is analogous to the complex-number \n; example of Section 2.4, where we allowed both rectangular and polar representations. \n; To do this we must distinguish different types of term lists and make the \n; operations on term lists generic. Redesign the polynomial system to implement this \n; generalization. This is a major effort, not a local change.\n\n; Dense package\n(define (install-polynomial-package-dense)\n    ;; internal procedures\n    ;; representation of poly\n    (define (make-poly variable term-list) (cons variable term-list))\n    (define (variable p) (car p))\n    (define (term-list p) (cdr p))\n    ; ⟨procedures same-variable? and variable? from section 2.3.2⟩\n    (define (variable? x) (symbol? x))\n    (define (same-variable? v1 v2)\n        (and (variable? v1) (variable? v2) (eq? v1 v2)))\n\n    ;; representation of terms\n    (define (adjoin-term term term-list)\n        (cond ((=zero? term) term-list)\n              ((= (order term) (length term-list))\n               (cons (coeff term) term-list))\n              (else (adjoin-term term\n                                 (cons 0 term-list)))))\n    (define (the-empty-termlist) '())\n    (define (first-term term-list)\n        (make-term \n               (- (length term-list) 1)\n               (car term-list)))\n    (define (rest-term term-list)\n        (cdr term-list))\n    (define (empty-termlist? term-list) (null? term-list))\n    (define (make-term order coeff) (list order coeff))\n    (define (order term) (car term))\n    (define (coeff term) (cadr term))\n\n    ;; Add\n    (define (add-poly p1 p2)\n        (if (same-variable? (variable p1) (variable p2))\n            (make-poly \n                (variable p1)\n                (add-terms (term-list p1) (term-list p2)))\n            (error \"Polys not in same var: ADD-POLY\" (list p1 p2))))\n    (define (add-terms L1 L2)\n        (cond ((empty-termlist? L1) L2)\n              ((empty-termlist? L2) L1)\n              (else\n                (let ((t1 (first-term L1))\n                      (t2 (first-term L2)))\n                    (cond ((> (order t1) (order t2))\n                           (adjoin-term\n                            t1\n                            (add-terms (rest-terms L1) L2)))\n                          ((< (order t1) (order t2))\n                           (adjoin-term\n                            t2\n                            (add-terms L1 (rest-terms L2))))\n                          (else\n                            (adjoin-term\n                                (make-term\n                                    (order t1)\n                                    (add (coeff t1) (coeff t2)))\n                                (add-terms \n                                    (rest-terms L1)\n                                    (rest-terms L2)))))))))\n\n    ;; Multiply\n    (define (mul-poly p1 p2)\n        (if (same-variable? (variable p1) (variable p2))\n            (make-poly \n                (variable p1)\n                (mul-terms (term-list p1) (term-list p2)))\n            (error \"Polys not in same var: MUL-POLY\" (list p1 p2))))\n    (define (mul-terms L1 L2)\n        (if (empty-termlist? L1)\n            (the-empty-termlist)\n            (add-terms\n                (mul-term-by-all-terms (first-term L1) L2)\n                (mul-terms (rest-terms) L2))))\n    (define (mul-term-by-all-terms t1 L)\n        (if (empty-termlist? L)\n            (the-empty-termlist)\n            (let ((t2 (first-term L)))\n                (adjoin-term\n                    (make-term\n                        (+ (order t1) (order t2))\n                        (mul (coeff t1) (coeff t2)))\n                    (mul-term-by-all-terms\n                        t1\n                        (rest-terms L))))))\n\n    ;; interface to rest of the system\n    (define (tag p) (attach-tag 'polynomial-dense p))\n    (put 'add '(polynomial-dense polynomial-dense)\n        (lambda (p1 p2) (tag (add-poly p1 p2))))\n    (put 'mul '(polynomial-dense polynomial-dense)\n        (lambda (p1 p2) (tag (mul-poly p1 p2))))\n    (put 'make 'polynomial-dense\n        (lambda (var terms) (tag (make-poly var terms))))\n    'done)\n\n; Sparse package\n(define (install-polynomial-package-sparse)\n    ;; internal procedures\n    ;; representation of poly\n    (define (make-poly variable term-list) (cons variable term-list))\n    (define (variable p) (car p))\n    (define (term-list p) (cdr p))\n    ; ⟨procedures same-variable? and variable? from section 2.3.2⟩\n    (define (variable? x) (symbol? x))\n    (define (same-variable? v1 v2)\n        (and (variable? v1) (variable? v2) (eq? v1 v2)))\n\n    ;; representation of terms\n    (define (adjoin-term term term-list)\n        (if (=zero? (coeff term))\n            term-list\n            (cons term term-list)))\n    (define (the-empty-termlist) '())\n    (define (first-term term-list) (car term-list))\n    (define (rest-terms term-list) (cdr term-list))\n    (define (empty-termlist? term-list) (null? term-list))\n    (define (make-term order coeff) (list order coeff))\n    (define (order term) (car term))\n    (define (coeff term) (cadr term))\n\n    ;; Add\n    (define (add-poly p1 p2)\n        (if (same-variable? (variable p1) (variable p2))\n            (make-poly \n                (variable p1)\n                (add-terms (term-list p1) (term-list p2)))\n            (error \"Polys not in same var: ADD-POLY\" (list p1 p2))))\n    (define (add-terms L1 L2)\n        (cond ((empty-termlist? L1) L2)\n              ((empty-termlist? L2) L1)\n              (else\n                (let ((t1 (first-term L1))\n                      (t2 (first-term L2)))\n                    (cond ((> (order t1) (order t2))\n                           (adjoin-term\n                            t1\n                            (add-terms (rest-terms L1) L2)))\n                          ((< (order t1) (order t2))\n                           (adjoin-term\n                            t2\n                            (add-terms L1 (rest-terms L2))))\n                          (else\n                            (adjoin-term\n                                (make-term\n                                    (order t1)\n                                    (add (coeff t1) (coeff t2)))\n                                (add-terms \n                                    (rest-terms L1)\n                                    (rest-terms L2)))))))))\n\n    ;; Multiply\n    (define (mul-poly p1 p2)\n        (if (same-variable? (variable p1) (variable p2))\n            (make-poly \n                (variable p1)\n                (mul-terms (term-list p1) (term-list p2)))\n            (error \"Polys not in same var: MUL-POLY\" (list p1 p2))))\n    (define (mul-terms L1 L2)\n        (if (empty-termlist? L1)\n            (the-empty-termlist)\n            (add-terms\n                (mul-term-by-all-terms (first-term L1) L2)\n                (mul-terms (rest-terms) L2))))\n    (define (mul-term-by-all-terms t1 L)\n        (if (empty-termlist? L)\n            (the-empty-termlist)\n            (let ((t2 (first-term L)))\n                (adjoin-term\n                    (make-term\n                        (+ (order t1) (order t2))\n                        (mul (coeff t1) (coeff t2)))\n                    (mul-term-by-all-terms\n                        t1\n                        (rest-terms L))))))\n    \n    ;; interface to rest of the system\n    (define (tag p) (attach-tag 'polynomial-sparse p))\n    (put 'add '(polynomial-sparse polynomial-sparse)\n        (lambda (p1 p2) (tag (add-poly p1 p2))))\n    (put 'mul '(polynomial-sparse polynomial-sparse)\n        (lambda (p1 p2) (tag (mul-poly p1 p2))))\n    (put 'make 'polynomial-sparse\n        (lambda (var terms) (tag (make-poly var terms))))\n    'done)\n"}}}},"pageContext":{"name":"2.90.scm","expr":"master:sicp/ch2-abstraction-data/2.90.scm"}}