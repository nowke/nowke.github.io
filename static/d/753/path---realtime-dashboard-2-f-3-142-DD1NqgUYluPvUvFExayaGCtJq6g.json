{"data":{"markdownRemark":{"html":"<p>In this post, we will be creating a simple scalable dashboard that updates in real-time using <a href=\"ll\">React</a>, <a href=\"ll\">GraphQL Subscriptions</a> and <a href=\"ll\">Redis PubSub</a>. Real-time dashboards can be used to monitor your <strong>infrastructure</strong> (servers, network, services), <strong>application traffic</strong> (transaction volume, number of users), <strong>alerts</strong> (application health, critical issues, downtimes) etc. Almost always, dashboards are backed up with one or more datasources.</p>\n<p>There are many open-source applications that can be used to create dashboards. For example, <strong><a href=\"ll\">Kibana</a></strong> can be used to visualize application logs integrated with <a href=\"ll\">ELK Stack</a>. <strong><a href=\"ll\">Grafana</a></strong> can be used to create a variety of visualizations on top of time series databases such as <a href=\"ll\">Prometheus</a>, <a href=\"ll\">Graphite</a> and <a href=\"ll\">OpenTSDB</a>. But, as of today, they support <a href=\"https://en.wikipedia.org/wiki/Pull_technology\">pull-based model</a>. That is, when a user opens the browser, application makes the queries and result is rendered. It is the most widely used model as opposed to a <a href=\"https://en.wikipedia.org/wiki/Push_technology\">Push model</a>. </p>\n<h2>When push-model can be used?</h2>\n<p>Assume you have a dashboard containing <strong><em>20 panels</em></strong>, querying data from multiple datasources at the backend in real-time. User has set a refresh rate of <strong><em>5 seconds</em></strong>. If, on an average <strong><em>100 users</em></strong> open the dashboard at any time - that is <strong><em>20 x 100 = 2000 requests</em></strong> every 5 seconds! This is manageable if you have good infrastructure for your underlying time-series database. Multiple Heavy queries can pile-up the memory. This problem can be solved either by introducing some intelligent caching, or a simple push-model using <a href=\"ll\">WebSockets</a>. It is useful (and simple), for the situation where multiple users are querying for the same data, at same or slightly-different time. </p>\n<ul>\n<li>Connection is established between server and client using WebSocket.</li>\n<li>Server sends the required data to Client at regular intervals</li>\n<li>If the connection breaks, client can retry indefinitely.</li>\n</ul>\n<h3>What are we building?</h3>\n<p>Here's the preview of a simple real-time dashboard we will be building. It contains 4 panels - CPU Utilization, Traffic information, Data-center distribution and alerts.</p>\n<img src=\"/demo-c4fc92aed4a93e02edf4e7e71dd700e5.gif\" alt=\"Real-time dashboard preview\" style=\"border: 1px solid #000;\">\n<h2>GraphQL Subscriptions</h2>\n<p><a href=\"ll\">GraphQL</a> is a query language for APIs and a runtime for fulfilling those queries with your existing data. Check out <a href=\"https://graphql.org/\">graphql.org</a> for more info if you are not familiar with GraphQL.</p>\n<p>Along with <a href=\"ll\">queries</a> and <a href=\"ll\">mutations</a>, GraphQL introduced one more specification - <a href=\"ll\">Subscriptions</a>. </p>\n<blockquote>\n<p> just as the list of mutations that the server supports describes all of the actions that a client can take, the list of subscriptions that the server supports describes all of the events that it can subscribe to. Just as a client can tell the server what data to refetch after it performs a mutation with a GraphQL selection, the client can tell the server what data it wants to be pushed with the subscription with a GraphQL selection. - <a href=\"https://graphql.org/blog/subscriptions-in-graphql-and-relay/\">GraphQL blog</a></p>\n</blockquote>\n<p>For example, client can subscribe for CPU data using the following subscription syntax</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-graphql line-numbers\"><code class=\"language-graphql\">subscription CPU <span class=\"token punctuation\">{</span>\n  cpu <span class=\"token punctuation\">{</span>\n    percentage\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>Server can publish the data at regular intervals,</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-js line-numbers\"><code class=\"language-js\">pubsub<span class=\"token punctuation\">.</span><span class=\"token function\">publish</span><span class=\"token punctuation\">(</span><span class=\"token constant\">CPU</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> cpu<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span> percentage<span class=\"token punctuation\">:</span> <span class=\"token number\">65</span> <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span></span></pre></div>\n<h2>Redis PubSub</h2>\n<p>Since version 2.0, Redis supports <a href=\"http://en.wikipedia.org/wiki/Publish/subscribe\">Publish-Subscribe pattern</a> using commands <a href=\"https://redis.io/commands/publish\">PUBLISH</a>, <a href=\"https://redis.io/commands/subscribe\">SUBSCRIBE</a> and <a href=\"https://redis.io/commands/unsubscribe\">UNSUBSCRIBE</a>. </p>","frontmatter":{"title":"Real-time Dashboard"}}},"pageContext":{"slug":"/realtime-dashboard/"}}