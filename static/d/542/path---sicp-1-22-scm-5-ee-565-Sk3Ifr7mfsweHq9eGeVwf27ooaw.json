{"data":{"github":{"repository":{"object":{"__typename":"GitHub_Blob","text":"; Most Lisp implementations include a primitive called \n; `runtime` that returns an integer that specifies the \n; amount of time the system has been running (measured, \n; for example, in microseconds). The following `timed-prime-test` \n; procedure, when called with an integer n, prints n and \n; checks to see if n is prime. If n is prime, the procedure \n; prints three asterisks followed by the amount of time used \n; in performing the test.\n(define (timed-prime-test n)\n    (newline)\n    (display n)\n    (start-prime-test n (runtime)))\n(define (start-prime-test n start-time)\n    (if (prime? n)\n        (report-prime (- (runtime) start-time)))) \n(define (report-prime elapsed-time)\n    (display \" *** \")\n    (display elapsed-time))\n\n; Using this procedure, write a procedure `search-for-primes` \n; that checks the primality of consecutive odd integers in a \n; specified range. Use your procedure to find the three \n; smallest primes larger than 1000; larger than 10,000; \n; larger than 100,000; larger than 1,000,000. Note the time \n; needed to test each prime. Since the testing algorithm has \n; order of growth of Θ(√n), you should expect that testing for \n; primes around 10,000 should take about √10 times as long as \n; testing for primes around 1000. Do your timing data bear this out? \n; How well do the data for 100,000 and 1,000,000 support the Θ(√n) \n; prediction? Is your result compatible with the notion that \n; programs on your machine run in time proportional to the number \n; of steps required for the computation?\n\n; ANSWER\n; Let's define `prime?` procedure\n(define (divides? a b) (= (remainder b a) 0))\n(define (prime? n)\n    (define (smallest-divisor n) (find-divisor n 2))\n    (define (find-divisor n test-divisor)\n        (cond ((> (square test-divisor) n) n)\n              ((divides? test-divisor n) test-divisor)\n              (else (find-divisor n (+ test-divisor 1)))))\n    (= n (smallest-divisor n))\n)\n; Write `search-for-primes` procedure\n(define (even? x) (= (remainder x 2) 0))\n(define (search-for-primes start end)\n    (define (search-for-primes-iter cur)\n        (if (<= cur end) (timed-prime-test cur))\n        (if (<= cur end) (search-for-primes-iter (+ 2 cur)))\n    )\n    (search-for-primes-iter (if (even? start) \n                                (+ 1 start)\n                                start)))\n\n(search-for-primes 1000 1020)\n(search-for-primes 10000 10050)\n(search-for-primes 1000000 1000100)\n\n; We almost see zero for computation time. \n; Hence we need to increase the quantity of numbers\n\n(search-for-primes 1000000000 1000000025)         ; 10^9\n(search-for-primes 10000000000 10000000080)       ; 10^10\n(search-for-primes 100000000000 100000000060)     ; 10^11\n(search-for-primes 1000000000000 1000000000065)   ; 10^12\n(search-for-primes 10000000000000 10000000000080) ; 10^13\n\n; On my MacBook air, the following times were reported\n; 10^9  => ~ 0.06\n; 10^10 => ~ 0.16\n; 10^11 => ~ 0.5\n; 10^12 => ~ 1.45\n; 10^13 => ~ 4.75\n\n; √10 ~ 3.16\n; If we calculate,\n; (a) Time(10^11) / Time(10^10) = 0.5 / 0.16 = 3.125\n; (b) Time(10^10) / Time(10^9)  = 0.16 / 0.06 = 2.67\n; (c) Time(10^12) / Time(10^11)  = 1.45 / 0.5 = 2.9\n; (c) Time(10^13) / Time(10^12)  = 4.75 / 1.45 = 3.275"}}}},"pageContext":{"name":"1.22.scm","expr":"master:sicp/ch1-abstraction-procedures/1.22.scm"}}