{"data":{"github":{"repository":{"object":{"__typename":"GitHub_Blob","text":"; Define a procedure square-tree analogous to the square-list procedure of \n; Exercise 2.21. That is, square-tree should behave as follows:\n; (square-tree\n;   (list 1\n;      (list 2 (list 3 4) 5)\n;      (list 6 7)))\n; (1 (4 (9 16) 25) (36 49))\n\n; Define square-tree both directly (i.e., without using any higher-order procedures) \n; and also by using map and recursion.\n\n; (i) Without using higher-order procedure\n(define (square-tree tree)\n    (cond ((null? tree) tree)\n          ((not (pair? tree)) (square tree))\n          (else (cons (square-tree (car tree))\n                      (square-tree (cdr tree))))))\n(square-tree\n    (list 1\n        (list 2 (list 3 4) 5)\n        (list 6 7)))\n;Value 2: (1 (4 (9 16) 25) (36 49))\n\n; (ii) Using `map`\n(define (square-tree tree)\n    (map (lambda (sub-tree)\n            (if (pair? sub-tree)\n                (square-tree sub-tree)\n                (square sub-tree)))\n         tree))\n(square-tree\n    (list 1\n        (list 2 (list 3 4) 5)\n        (list 6 7)))\n;Value 3: (1 (4 (9 16) 25) (36 49))"}}}},"pageContext":{"name":"2.30.scm","expr":"master:sicp/ch2-abstraction-data/2.30.scm"}}