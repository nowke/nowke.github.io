{"data":{"github":{"repository":{"object":{"__typename":"GitHub_Blob","text":"; The good-enough? test used in computing square roots \n; will not be very effective for finding the square \n; roots of very small numbers. Also, in real computers, \n; arithmetic operations are almost always performed with \n; limited precision. This makes our test inadequate for very \n; large numbers. Explain these statements, with examples showing \n; how the test fails for small and large numbers. An alternative \n; strategy for implementing `good-enough?` is to watch how guess \n; changes from one iteration to the next and to stop when the \n; change is a very small fraction of the guess. Design a square-root \n; procedure that uses this kind of end test. Does this work better \n; for small and large numbers?\n\n; \n; Let's define the previously mentioned square root functions for\n; testing small numbers\n(define (average x y) (/ (+ x y) 2))\n(define (square x) (* x x))\n\n(define (improve guess x) (average guess (/ x guess)))\n(define (good-enough? guess x)\n  (< (abs (- (square guess) x)) 0.001)\n)\n\n(define (sqrt-iter guess x) \n  (if (good-enough? guess x)\n    guess\n    (sqrt-iter (improve guess x) x)\n  )\n)\n\n(define (sqrt x)\n  (sqrt-iter 1.0 x)\n)\n;  Let's try some small numbers\n(sqrt 0.004) ; res = .06548128198973399, actual = 0.0632455532\n(sqrt 0.0006) ; res = 3.7397194007827136e-2, actual = 2.449489743e-2\n; As we can observe, our `good-enough?` test fails as the number becomes smaller\n\n; Alternative `good-enough?` function can be,\n; (latestGuess - previousGuess)/previousGuess is less than 0.001 (fraction change)\n(define (good-enough-alt? guess x)\n    (< (abs (/ \n             (- (improve guess x) guess) \n             guess)) 0.001)\n)"}}}},"pageContext":{"name":"1.07.scm","expr":"master:sicp/ch1-abstraction-procedures/1.07.scm"}}