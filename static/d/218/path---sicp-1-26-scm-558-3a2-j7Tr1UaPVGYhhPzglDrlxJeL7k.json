{"data":{"github":{"repository":{"object":{"__typename":"GitHub_Blob","text":"; Louis Reasoner is having great difficulty doing Exercise 1.24. \n; His fast-prime? test seems to run more slowly than his prime? \n; test. Louis calls his friend Eva Lu Ator over to help. When \n; they examine Louis’s code, they find that he has rewritten \n; the expmod procedure to use an explicit multiplication, \n; rather than calling square:\n(define (expmod base exp m) \n    (cond ((= exp 0) 1)\n          ((even? exp)\n           (remainder (* (expmod base (/ exp 2) m)\n                         (expmod base (/ exp 2) m))\n                      m))\n          (else\n            (remainder (* base\n                          (expmod base (- exp 1) m))\n                       m))))\n; “I don’t see what difference that could make,” says Louis. \n; “I do.” says Eva. “By writing the procedure like that, you \n;  have transformed the Θ(logn) process into a Θ(n) process.” \n; Explain.\n\n; ANSWER\n; Explicit multiplication will compute (expmod ...) first,\n; and square the result later\n; But, in this case, (expmod ...) is computed twice and\n; squared later. Morever, this becomes a tree-recursion with\n; execution time is linear."}}}},"pageContext":{"name":"1.26.scm","expr":"master:sicp/ch1-abstraction-procedures/1.26.scm"}}