{"data":{"github":{"repository":{"object":{"__typename":"GitHub_Blob","text":"(load \"packages/general.scm\")\n(load \"packages/polar.scm\")\n(load \"packages/rectangular.scm\")\n    \n; Generic arithmetic packages\n(define (add x y) (apply-generic 'add x y))\n(define (sub x y) (apply-generic 'sub x y))\n(define (mul x y) (apply-generic 'mul x y))\n(define (div x y) (apply-generic 'div x y))\n(define (=zero? x) (apply-generic '=zero? x))\n(define (negate x) (apply-generic 'negate x))\n\n; Primitive package\n(define (install-scheme-number-package)\n    (define (tag x) (attach-tag 'scheme-number x))\n    (put 'add '(scheme-number scheme-number)\n         (lambda (x y) (tag (+ x y))))\n    (put 'sub '(scheme-number scheme-number)\n         (lambda (x y) (tag (- x y))))\n    (put 'mul '(scheme-number scheme-number)\n         (lambda (x y) (tag (* x y))))\n    (put 'div '(scheme-number scheme-number)\n         (lambda (x y) (tag (/ x y))))\n    (put 'equ? '(scheme-number scheme-number) =)\n    (put '=zero? '(scheme-number) (lambda (x) (= x 0)))\n    (put 'negate '(scheme-number) (lambda (x) (tag (- x))))\n    (put 'make 'scheme-number (lambda (x) (tag x))) \n    'done)\n\n(define (make-scheme-number n) \n    ((get 'make 'scheme-number) n))\n\n; Rational number package\n(define (install-rational-package) ;; internal procedures\n    (define (numer x) (car x))\n    (define (denom x) (cdr x)) \n    (define (make-rat n d)\n        (let ((g (gcd n d)))\n            (cons (/ n g) (/ d g))))\n    (define (add-rat x y)\n        (make-rat (+ (* (numer x) (denom y))\n                     (* (numer y) (denom x)))\n                  (* (denom x) (denom y))))\n    (define (sub-rat x y)\n        (make-rat (- (* (numer x) (denom y))\n                     (* (numer y) (denom x)))\n                  (* (denom x) (denom y))))\n    (define (mul-rat x y)\n        (make-rat (* (numer x) (numer y))\n                  (* (denom x) (denom y)))) \n    (define (div-rat x y)\n        (make-rat (* (numer x) (denom y))\n                  (* (denom x) (numer y))))\n    ;; interface to rest of the system\n    (define (tag x) (attach-tag 'rational x))\n    (put 'add '(rational rational)\n         (lambda (x y) (tag (add-rat x y))))\n    (put 'sub '(rational rational)\n         (lambda (x y) (tag (sub-rat x y)))) \n    (put 'mul '(rational rational)\n         (lambda (x y) (tag (mul-rat x y)))) \n    (put 'div '(rational rational)\n         (lambda (x y) (tag (div-rat x y))))\n    (put 'equ? '(rational rational)\n         (lambda (x y) \n            (and (= (numer x) (numer y))\n                 (= (denom x) (denom y)))))\n    (put '=zero? '(rational) (lambda (x) (= (numer x) 0)))\n    (put 'negate '(rational) \n         (lambda (x) (make-rat (- numer x) (denom x))))\n    (put 'make 'rational\n         (lambda (n d) (tag (make-rat n d))))\n    'done)\n\n(define (make-rational n d)\n    ((get 'make 'rational) n d))\n\n; Complex number package\n(define (install-complex-package)\n    ;; imported procedures from rectangular and polar packages \n    (define (make-from-real-imag x y)\n        ((get 'make-from-real-imag 'rectangular) x y)) \n    (define (make-from-mag-ang r a)\n        ((get 'make-from-mag-ang 'polar) r a)) \n    ;; internal procedures\n    (define (add-complex z1 z2)\n        (make-from-real-imag \n            (+ (real-part z1) (real-part z2))\n            (+ (imag-part z1) (imag-part z2))))\n    (define (sub-complex z1 z2)\n        (make-from-real-imag \n            (- (real-part z1) (real-part z2))\n            (- (imag-part z1) (imag-part z2)))) \n    (define (mul-complex z1 z2)\n        (make-from-mag-ang \n            (* (magnitude z1) (magnitude z2))\n            (+ (angle z1) (angle z2))))\n    (define (div-complex z1 z2)\n        (make-from-mag-ang \n            (/ (magnitude z1) (magnitude z2))\n            (- (angle z1) (angle z2)))) \n    ;; interface to rest of the system\n    (define (tag z) (attach-tag 'complex z))\n    (put 'add '(complex complex)\n         (lambda (z1 z2) (tag (add-complex z1 z2))))\n    (put 'sub '(complex complex)\n         (lambda (z1 z2) (tag (sub-complex z1 z2))))\n    (put 'mul '(complex complex)\n         (lambda (z1 z2) (tag (mul-complex z1 z2))))\n    (put 'div '(complex complex)\n         (lambda (z1 z2) (tag (div-complex z1 z2))))\n    (put 'equ? '(complex complex)\n         (lambda (z1 z2)\n            (and (= (real-part z1) (real-part z2))\n                 (= (imag-part z1) (imag-part z2)))))\n    (put '=zero? '(complex) (lambda (z) (= (real-part z) (imag-part z) 0)))\n    (put 'negate '(complex)\n         (lambda (z) (make-from-real-imag \n                         (- (real-part z))\n                         (- (imag-part z)))))\n    (put 'make-from-real-imag 'complex\n         (lambda (x y) (tag (make-from-real-imag x y))))\n    (put 'make-from-mag-ang 'complex\n         (lambda (r a) (tag (make-from-mag-ang r a))))\n    'done)\n(install-scheme-number-package)\n(install-rectangular-package)\n(install-polar-package)\n(install-complex-package)\n(install-rational-package)\n\n(define (make-complex-from-real-imag x y) \n    ((get 'make-from-real-imag 'complex) x y))\n(define (make-complex-from-mag-ang r a) \n    ((get 'make-from-mag-ang 'complex) r a))\n"}}}},"pageContext":{"name":"arithmetic-package.scm","expr":"master:sicp/ch2-abstraction-data/arithmetic-package.scm"}}