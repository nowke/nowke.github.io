{"data":{"github":{"repository":{"object":{"__typename":"GitHub_Blob","text":"; The `smallest-divisor` procedure shown at the start \n; of this section does lots of needless testing: After \n; it checks to see if the number is divisible by 2 there \n; is no point in checking to see if it is divisible by any \n; larger even numbbers. This suggests that the values \n; used for test-divisor should not be 2, 3, 4, 5, 6, . . ., \n; but rather 2, 3, 5, 7, 9, . . ..\n; To implement this change, define a procedure next that \n; returns 3 if its input is equal to 2 and otherwise returns \n; its input plus 2. Modify the smallest-divisor procedure \n; to use (next test-divisor) instead of (+ test-divisor 1). \n; With timed-prime-test incorporating this modified version \n; of smallest-divisor, run the test for each of the 12 primes \n; found in Exercise 1.22. Since this modification halves the \n; number of test steps, you should expect it to run about twice as fast. \n; Is this expectation confirmed? If not, what is the observed ratio\n; of the speeds of the two algorithms, and how do you explain the \n; fact that it is different from 2?\n(define (divides? a b) (= (remainder b a) 0))\n(define (prime? n)\n    (define (smallest-divisor n) (find-divisor n 2))\n    (define (find-divisor n test-divisor)\n        (cond ((> (square test-divisor) n) n)\n              ((divides? test-divisor n) test-divisor)\n              (else (find-divisor n (next test-divisor)))))\n    (= n (smallest-divisor n))\n)\n(define (next n)\n  (if (= n 2)\n      3\n      (+ n 2)))\n; Timed prime test\n(define (timed-prime-test n)\n    (newline)\n    (display n)\n    (start-prime-test n (runtime)))\n(define (start-prime-test n start-time)\n    (if (prime? n)\n        (report-prime (- (runtime) start-time)))) \n(define (report-prime elapsed-time)\n    (display \" *** \")\n    (display elapsed-time))\n\n; 12 primes found in `Exercise 1.22`\n(timed-prime-test 1000000007)    ; .03\n(timed-prime-test 1000000009)    ; .03\n(timed-prime-test 1000000021)    ; .04000000000000001\n(timed-prime-test 10000000019)   ; .08999999999999997\n(timed-prime-test 10000000033)   ; .09000000000000002\n(timed-prime-test 10000000061)   ; .08999999999999997\n(timed-prime-test 100000000003)  ; .27 \n(timed-prime-test 100000000019)  ; .30000000000000004\n(timed-prime-test 100000000057)  ; .28\n(timed-prime-test 1000000000039) ; 1.0399999999999998\n(timed-prime-test 1000000000061) ; .8500000000000001\n(timed-prime-test 1000000000063) ; .8600000000000003\n\n; Comparing the order v/s time from previous and current\n; implementations\n; ------------------------------------------------\n; | Order  | Previous | Current | Factor reduced |\n; |----------------------------------------------|\n; |  10^9  |   0.06   |  0.04   |    1.5         |\n; |  10^10 |   0.16   |  0.9    |    1.77        |\n; |  10^11 |   0.5    |  0.3    |    1.66        |\n; |  10^12 |   1.45   |  0.85   |    1.7         |\n; |----------------------------------------------|\n;\n; As we observe, factor reduced is not exactly 2, but ~1.5-1.6\n; This is because, we spend some time during IF condition\n; present in `next` procedure"}}}},"pageContext":{"name":"1.23.scm","expr":"master:sicp/ch1-abstraction-procedures/1.23.scm"}}