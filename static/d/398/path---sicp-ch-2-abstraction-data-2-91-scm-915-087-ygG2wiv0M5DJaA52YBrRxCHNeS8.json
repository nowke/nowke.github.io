{"data":{"github":{"repository":{"object":{"__typename":"GitHub_Blob","text":"; A univariate polynomial can be divided by another one to produce a polynomial \n; quotient and a polynomial remainder. For example,\n;\n; $\\frac{x^5 - 1}{x^2 - 1} = x^3 + x$, remainder $x-1$\n;\n; Division can be performed via long division. That is, divide the highest-order \n; term of the dividend by the highest-order term of the divisor. The result is the \n; first term of the quotient. Next, multiply the result by the divisor, subtract \n; that from the dividend, and produce the rest of the answer by recursively dividing\n; the difference by the divisor. Stop when the order of the divisor exceeds the order\n; of the dividend and declare the dividend to be the remainder. Also, if the dividend\n; ever becomes zero, return zero as both quotient and remainder.\n;\n; We can design a div-poly procedure on the model of add- poly and mul-poly. The \n; procedure checks to see if the two polys have the same variable. If so, div-poly \n; strips off the variable and passes the problem to div-terms, which performs the \n; division operation on term lists. div-poly finally reattaches the variable to the \n; result supplied by div-terms. It is convenient to design div-terms to compute both\n; the quotient and the remainder of a division. div-terms can take two term lists as\n; arguments and return a list of the quotient term list and the remainder term list.\n;\n; Complete the following definition of div-terms by filling in the missing expressions. \n; Use this to implement div-poly, which takes two polys as arguments and returns a \n; list of the quotient and remainder polys.\n\n; Add the following to `polynomial` package\n(define (div-terms L1 L2) \n    (if (empty-termlist? L1)\n        (list (the-empty-termlist) (the-empty-termlist)) \n        (let ((t1 (first-term L1))\n              (t2 (first-term L2)))\n            (if (> (order t2) (order t1))\n                (list (the-empty-termlist) L1)\n                (let ((new-c (div (coeff t1) (coeff t2)))\n                      (new-o (- (order t1) (order t2)))) \n                    (let ((rest-of-result\n                          (div-terms\n                            (add-terms\n                                L1\n                                (negate-terms\n                                    (mul-term-by-all-terms\n                                        (make-term new-o new-c)\n                                        L2)))\n                            L2))) \n                        (cons\n                            (adjoin-term\n                                (make-term new-o new-c)\n                                (car rest-of-result))\n                            (cdr rest-of-result))))))))\n\n; Redefining the polynomial package\n(define (install-polynomial-package)\n    ;; internal procedures\n    ;; representation of poly\n    (define (make-poly variable term-list) (cons variable term-list))\n    (define (variable p) (car p))\n    (define (term-list p) (cdr p))\n    ; ⟨procedures same-variable? and variable? from section 2.3.2⟩\n    (define (variable? x) (symbol? x))\n    (define (same-variable? v1 v2)\n        (and (variable? v1) (variable? v2) (eq? v1 v2)))\n\n    ;; representation of terms and term lists\n    ;; ⟨procedures adjoin-term . . . coeff from text below⟩\n\n    ;; Add\n    (define (add-poly p1 p2)\n        (if (same-variable? (variable p1) (variable p2))\n            (make-poly \n                (variable p1)\n                (add-terms (term-list p1) (term-list p2)))\n            (error \"Polys not in same var: ADD-POLY\" (list p1 p2))))\n    (define (add-terms L1 L2)\n        (cond ((empty-termlist? L1) L2)\n              ((empty-termlist? L2) L1)\n              (else\n                (let ((t1 (first-term L1))\n                      (t2 (first-term L2)))\n                    (cond ((> (order t1) (order t2))\n                           (adjoin-term\n                            t1\n                            (add-terms (rest-terms L1) L2)))\n                          ((< (order t1) (order t2))\n                           (adjoin-term\n                            t2\n                            (add-terms L1 (rest-terms L2))))\n                          (else\n                            (adjoin-term\n                                (make-term\n                                    (order t1)\n                                    (add (coeff t1) (coeff t2)))\n                                (add-terms \n                                    (rest-terms L1)\n                                    (rest-terms L2)))))))))\n\n    ;; Multiply\n    (define (mul-poly p1 p2)\n        (if (same-variable? (variable p1) (variable p2))\n            (make-poly \n                (variable p1)\n                (mul-terms (term-list p1) (term-list p2)))\n            (error \"Polys not in same var: MUL-POLY\" (list p1 p2))))\n    (define (mul-terms L1 L2)\n        (if (empty-termlist? L1)\n            (the-empty-termlist)\n            (add-terms\n                (mul-term-by-all-terms (first-term L1) L2)\n                (mul-terms (rest-terms) L2))))\n    (define (mul-term-by-all-terms t1 L)\n        (if (empty-termlist? L)\n            (the-empty-termlist)\n            (let ((t2 (first-term L)))\n                (adjoin-term\n                    (make-term\n                        (+ (order t1) (order t2))\n                        (mul (coeff t1) (coeff t2)))\n                    (mul-term-by-all-terms\n                        t1\n                        (rest-terms L))))))\n    \n    (define (poly-zero? term-list)\n        (if (empty-termlist? term-list)\n            #t\n            (and (=zero? (coeff (first-term term-list)))\n                 (poly-zero? (rest-terms term-list)))))\n    ;; Subtraction\n    (define (negate-terms term-list)\n        (if (empty-termlist? term-list)\n            the-empty-termlist\n            (adjoin-term\n                (make-term \n                    (order (first-term term-list)) \n                    (negate (coeff (first-term term-list))))\n                (negate-terms (rest-terms term-list)))))\n    (define (sub-poly p1 p2)\n        (if (same-variable? (variable p1) (variable p2))\n            (make-poly \n                (variable p1)\n                (add-terms (term-list p1) (negate-terms (term-list p2))))\n            (error \"Polys not in same var: SUB-POLY\" (list p1 p2))))\n\n    ;; Division\n    (define (div-terms L1 L2) \n        (if (empty-termlist? L1)\n            (list (the-empty-termlist) (the-empty-termlist)) \n            (let ((t1 (first-term L1))\n                  (t2 (first-term L2)))\n                (if (> (order t2) (order t1))\n                    (list (the-empty-termlist) L1)\n                    (let ((new-c (div (coeff t1) (coeff t2)))\n                          (new-o (- (order t1) (order t2)))) \n                        (let ((rest-of-result\n                              (div-terms\n                                (add-terms\n                                    L1\n                                    (negate-terms \n                                        (mul-term-by-all-terms\n                                            (make-term new-o new-c)\n                                            L2)))\n                                L2))) \n                            (list\n                                (adjoin-term\n                                    (make-term new-o new-c)\n                                    (car rest-of-result))\n                                (cadr rest-of-result))))))))\n    (define (div-poly p1 p2)\n        (if (same-variable? (variable p1) (variable p2))\n            (let ((ans (div-terms (term-list p1)\n                                  (term-list p2))))\n                (list (make-poly (variable p1)\n                                 (car ans))\n                      (make-poly (variable p1)\n                                 (cadr ans))))\n            (error \"Polys not in same var: DIV-POLY\" (list p1 p2))))\n\n    ;; interface to rest of the system\n    (define (tag p) (attach-tag 'polynomial p))\n    (put '=zero? '(polynomial) (lambda (p) (poly-zero? (term-list p))))\n    (put 'add '(polynomial polynomial)\n        (lambda (p1 p2) (tag (add-poly p1 p2))))\n    (put 'mul '(polynomial polynomial)\n        (lambda (p1 p2) (tag (mul-poly p1 p2))))\n    (put 'div '(polynomial polynomial)\n        (lambda (p1 p2) (tag (div-poly p1 p2))))\n    (put 'make 'polynomial\n        (lambda (var terms) (tag (make-poly var terms))))\n    (put 'negate '(polynomial)\n        (lambda (p) \n            (make-polynomial \n                (variable p)\n                (negate-terms (term-list p)))))\n    (put 'sub '(polynomial polynomial)\n        (lambda (p1 p2) (tag (sub-poly p1 p2))))\n    'done)\n\n;; representation of terms\n(define (adjoin-term term term-list)\n    (if (=zero? (coeff term))\n        term-list\n        (cons term term-list)))\n(define (the-empty-termlist) '())\n(define (first-term term-list) (car term-list))\n(define (rest-terms term-list) (cdr term-list))\n(define (empty-termlist? term-list) (null? term-list))\n(define (make-term order coeff) (list order coeff))\n(define (order term) (car term))\n(define (coeff term) (cadr term))\n\n(define (make-polynomial var terms)\n    ((get 'make 'polynomial) var terms))\n\n; Testing\n(load \"arithmetic-package.scm\")\n\n(install-polynomial-package)\n\n(define p1 \n    (make-polynomial \n        'x\n        (list (make-term  5  (make-scheme-number 1))\n              (make-term  0  (make-scheme-number -1))))) ; x^5 - 1\n\n(define p2 \n    (make-polynomial \n        'x\n        (list (make-term  2  (make-scheme-number 1))\n              (make-term  0  (make-scheme-number -1))))) ; x^2 - 1\n\n(div p1 p2)\n; Note: This returns an error, couldn't get this working :/"}}}},"pageContext":{"name":"2.91.scm","expr":"master:sicp/ch2-abstraction-data/2.91.scm"}}